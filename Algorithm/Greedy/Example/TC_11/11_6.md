# 무지의 먹방라이브

https://programmers.co.kr/learn/courses/30/lessons/42891

그냥 계속 돌면서 하나씩 줄게 하고 k번째에 어디인지 확인하면 되는거 아닌가?

​

하는 생각으로 구현하면 시간 초과다. 

​

문제에서 얘기한 대로 구현하는 것이 아니라 

"먼저 다 먹게될 음식이 뭔가?"를 생각해야 한다. 

​

먹는데 가장 시간이 적게 걸리는 음식이 먼저 없어질 것이다.

그리고 이 음식이 없어지면 다른 음식들 중 장애가 일어나는 시간에 먹어야 했던 음식을 찾으면 된다. 

​

네트워크 장애가 걸리지 않아서 무지가 모든 음식을 먹는다고 할 때의 상황을 생각해보자

처음에 어떤 음식이 없어지는 시간은 (해당하는 음식의 소요시간) * (남은 음식의 개수) - (음식의 순서)이다.

이때 음식의 순서는 0부터 시작

​

7, 2, 4

이렇게 음식이 있다고 할 때, 2번 음식이 없어질 시간은?

2 * 3 - 1 = 5 이다. 

5초가 지나고 나서 다음과 같을 것이다.

​

5, 0, 3

이 상황에서 소요시간이 가장 적은 음식은 3번 음식이다.

이 음식이 없어질 시간은? 이때, 먹기 시작할 음식은 3번 음식

3 * 2 - 1 = 5

이 상황에서 5초(총 10초)가 지나고 나서 다음과 같을 것이다. 

​

3, 0, 0

​

시작하는 순서를 계속해서 맨 앞으로 맞춰보자

(해당하는 음식의 소요시간) * (남은 음식의 개수)

​

7, 2, 4

2번 음식이 없어지고 시작이 맨앞이 되는 시간은

2 * 3 = 6

6초가 지나고 나서 다음과 같을 것이다.

​

5, 0, 2

이 상황에서 3번 음식이 없어지고 시작이 맨앞이 되는 시간은

2 * 2 = 4

총 6+4초가 지나고 나서 다음과 같을 것이다.

​

3, 0, 0

​

이제 2번 음식이 없어지고 난 상황에서 각 음식의 소요시간의 변화를 보자

1번 음식 3번 음식 모두 앞에서 없어진 2번 음식의 소요시간 만큼 각각의 소요시간이 줄어들었다.

​

이제는 어떤 k의 시간에서 먹어야 할 음식을 찾아야한다고 생각하자

​

7, 2, 4 

k = 4

가장 빨리 없어지는 2번 음식은 없어지는데 6초가 걸린다.

그런데 그 전에 장애가 발생한다.

이럴때는 단순히 1번 부터 하나씩 순서를 세본다.

1->2->3->1

4초에는 1번 음식을 먹어야하므로 장애가 해결되면 1번 음식을 먹어야 한다. 

​

7, 2, 4

k = 8

2번 음식은 6초가 되면 모두 없어진다. 

6초가 지난 상황에서 가장 빨리 없어지는 3번 음식은 추가로 4초가 더 걸린다. 

그 전에 장애가 발생하므로 순서를 세본다.

1 -> 3

​

이런 식으로 동작하게 구현하면 된다.

1. 가장 소요시간이 적은 음식이 없어질 시간 과 k를 비교한다.

2. k가 더 크다면 

    -  각각의 음식에서 해당 음식의 소요시간을 빼준다

    -  k에서 해당 음식이 없어질 시간을 빼준다.

    -  해당 음식을 리스트에서 제외한다.

    -  1번으로 돌아간다.

3. k가 더 작다면 남은 음식의 순서를 k만큼 진행한다.

​

계속해서 소요시간이 가장 적은 음식을 뽑아야 하므로 우선순위 큐 형태여야 한다. 

몇번째 음식인지 알아야하므로, 소요시간과 인덱스를 같이 저장한다.

다음과 같은 코드로 구현하였다.


처음에는 이미 다먹은 음식에 대해서 erase를 썼는데 그렇게 되면 효율성 테스트에서 실패하게 된다.

vector의 erase는 보통 O(N)의 시간복잡도를 가진다고 한다.


그래서 erase 하지 않고 마지막에 순서를 생각해야 할 때 아직 확인하지 않은 음식만을 정렬하는 방식을 사용했다.


그리고 효율성 테스트에서는 숫자의 단위가 많이 커지므로, spend를 계산하거나 총 시간을 계산하는 경우 long long 타입을 사용해야 한다.

~~~
#include <string>
#include <algorithm>
#include <vector>

using namespace std;

bool idxCmp (pair<int, int> x, pair<int, int> y) { return x.second < y.second; }

int solution(vector<int> food_times, long long k) {
    int size = food_times.size(), prev = 0, i;
    long long spend = 0;
    
    vector<pair<int, int>> pq;
    for(i = 0; i < size; i++) {
        pq.emplace_back(food_times[i], i+1);
        spend += food_times[i];
    }
    
    if(spend <= k) return -1;
    
    sort(pq.begin(), pq.end());
    for(i = 0; i < pq.size(); i++, size--) {
        spend = (long long)(pq[i].first - prev) * size;
        if(spend > k) break;
        k -= spend;
        prev = pq[i].first;
    }
    
    sort(pq.begin()+i, pq.end(), idxCmp);
    return pq[k%size+i].second;
}
~~~

C++ Container 별 시간복잡도와 문제에서 변수들의 숫자 범위 체크는 중요하다. (당연한 소리)
