# Bubble Sort

1. 순차적으로 두 개의 원소씩 비교하여, 만약 앞의 원소가 뒤의 원소보다 크면 자리를 바꾼다.

2. 끝까지 진행하면 가장 마지막 원소는 배열에서 가장 큰 원소이므로 자리가 확정된다. 확정된 원소를 제외하고 다시 처음 부터 1 단계 진행

~~~
// One Step Of Bubble Sort
void BubbleSort0(int A[ ], int n) {
    int i;
    for (i ＝ 1; i ＜ n; i++) 
        if (A[i－1] ＞ A[i])
            Swap(&A[i－1], &A[i]);
}
~~~

## 시간 단축 방법

한 단계를 시작하기 전에 

바로 전의 단계에서 자리바꿈이 일어났는지 검사하여 자리바꿈이 일어나지 않은 경우에는 

배열이 이미 정렬된 것이므로 다음 단계를 생략하고 알고리즘의 실행을 끝냄

예를 들어 다음과 같은 배열을 버블 정렬로 정렬하려 한다.

~~~
30  20  40  10	5	10	30	15
~~~

단계 별로 확정된 원소를 |로 표시하면 다음과 같다.

~~~
1 : 20  30  10  5   10  30  15  |   40

2 : 20  10  5   10  30  15  |   30  40

3 : 10  5   10  20  15  |   30  30  40

4 : 5   10  10  15  |   20  30  30  40
~~~

여기서 졍렬을 끝까지 진행하지 않았는데 이미 원소가 정렬되어 있는 것을 볼 수 있다.

5 단계에서는 자리 바꿈이 일어나지 않는 데, 이를 6단계에서 알아채고 멈추면 시간을 단축할 수 있다. 

~~~	
bool Sorted ＝ FALSE;

void BubbleSort(int A[ ], int n) {
	int i;

	while (!Sorted) {
        Sorted ＝ TRUE;
        for (i ＝ 1; i ＜ n; i++) 		
            if (A[i－1] ＞ A[i]) {
                Swap(&A[i－1], &A[i]);
                Sorted ＝ FALSE; 	    
            }
	}
}
~~~

Sorted라는 불리언을 추가해서 한번이라도 바뀌면

## 시간 복잡도

최악 : O(n^2)

역순으로 이미 정렬되어 있는 경우

## 제자리성 : O

입력 원소 이외에 다른 메모리가 사용되고 있지 않다.

## 안정성 : O

앞의 원소가 큰 경우가 아니라면 위치가 바뀌지 않음