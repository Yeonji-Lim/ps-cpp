# Shell Sort

배열의 원소를 볼 때 인덱스를 하나씩 증가시키지 않고, 어떤 수만큼 인덱스를 증가시키면서 보고 그 원소들끼리 삽입정렬

즉 부분배열을 만들어서 정렬. 부분배열의 개수를 h라고 하자

예를 들어서 배열이 다음과 같고 h = 4라고 하면,

~~~
30	50	15  60  |   35  10	40	45  |   5	25	55	20
~~~

30, 35, 5를 보고 5, 30, 35로 정렬

50, 10, 25를 보고 10, 25, 50으로 정렬

15, 40, 55를 보고 15, 40, 55로 정렬

60, 45, 20을 보고 20, 45, 60으로 정렬

~~~
5   10  15  20  |   30  25  40  45  |   35  50  55  60
~~~

이 뒤로 h를 줄여가며 정렬 진행

부분배열의 개수를 정하기 위하여 

양수로 이루어진 임의의 순열 인 hk, hk-1,…, h1를 선택하는데 

~~~
이때 1<i<k 인 i에 대하여 hi-1<hi<hi+1이 만족되도록 함. 

또한 임의의 i와 j에 대하여 i<j 이면 hj가 hi의 배수가 되지 않도록 하며 h1=1이 되도록 함
~~~

~~~
void ShellSort(int A[ ], int n){
    int h, i, j, Value;
    h ＝ 1;
    do h ＝ 3 * h ＋ 1; while (h ＜ n); // n 값에 따라 h값 증가 ex> n=12, h=13
    do { 
        h ＝ h / 3;
        for(i ＝ h; i < n; i++) { 
            Value ＝ A[i];
            j ＝ i;
            while (A[j－h] ＞ Value){ //4개씩 떨어진 원소끼리 삽입정렬
                A[j] ＝ A[j－h]; 
                j -= h;
                if (j ＜h-1) break; }
            A[j] ＝ Value; 
        }
    }
    while ( h ＞ 1); 
}
~~~

## 시간복잡도

실생시간 계산이 복잡하다

h=1,4,13,40,… 일 때 최악의 시간복잡도가 n^(3/2)로 증명되어 있다.

원소의 개수가 5000개 되는 큰 배열에서도 효율적이다.

## 제자리성 : O

i, j, Value등 상수크기의 메모리

## 안정성 : X

인접한 원소끼리 하지 않고 건너 뛰어서 비교하기 때문에 불안정

