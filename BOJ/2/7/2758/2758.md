230808
# 첫번째 시도 
로직을 잘못 생각했다. 앞의 숫자를 선택하고 나서 뒤에 선택가능한 숫자를 고르는 과정은 앞의 과정과 완전히 동일하지 않다.

1을 고르고 두번째 숫자를 골라야 할 때 가능한 숫자는

2, 3, 4, ..

이때 두번째로 2를 고르면 세번째 숫자를 골라야 할 때 가능한 숫자는

4, 5, 6, ..

가장 똑같이 가장 앞에 있는 숫자를 고르더라도 

첫번째 숫자인 1을 골랐을 때는 바로 다음 수부터 고르기 가능하지만,

두번재 숫자인 2를 골랐을 때는 바로 다음 수인 3부터 고를 수 없다. 

그런 이유로 다음과 같은 로직은 성립할 수 없다

```cpp
#include <iostream>

using namespace std;

int t,n,m,ans;
int dp[11][2001];

int choose(int tn, int tm) {
    if(tn > tm) return -1;
	if(dp[tn][tm]!=0) return dp[tn][tm];
	if(tn == 1) dp[tn][tm] = tm;
	else {
	    for(int i=0; 2*i+1 < tm && tn <= tm-2*i; i++) {
	    	dp[tn][tm] += choose(tn-1,tm-2*i-1);
	    }
	}
	return dp[tn][tm];
}

int main() {
	cin >> t;
	while(t--) {
		cin >> n >> m;
		ans = choose(n,m);
        if(ans > 0) cout << ans << '\n';
        else cout << "-1\n";
	}
	return 0;
}
```

# 해설보고 정리

dp로 푸는 것은 같음.. 조합을 생각했으나 그런 문제가 아니었다.

표로 생각을 해본다.

가로가 고를 숫자이고 세로가 골라야하는 순서

해당 순서에 해당 숫자를 고를 수 있는 경우의 수를 채운다고 생각하자

첫번째 숫자는 모두 고를 수 있다.

|   | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 
|---|---|---|---|---|---|---|---|---|---|---|
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 2 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 
| 3 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 
| 4 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 

두번째 숫자부터는 앞의 숫자가 어떤 수이냐에 따라 고를 수 잇는 숫자가 달라진다.

만약 첫번째 숫자가 1인 경우 2 부터 고르기 가능

|   | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 
|---|---|---|---|---|---|---|---|---|---|---|
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 2 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 3 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 
| 4 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 

만약 첫번째 숫자가 2인 경우 4 부터 고르기 가능하므로 4부터 경우의 수를 하나씩 늘린다.

|   | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 
|---|---|---|---|---|---|---|---|---|---|---|
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 2 | 0 | 1 | 1 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
| 3 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 
| 4 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

이런 식으로 첫번째 숫자에 따라 각 경우의 수에 더해서 두번째 숫자의 경우의 수를 완성할 수 있다.

|   | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 
|---|---|---|---|---|---|---|---|---|---|---|
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 2 | 0 | 1 | 1 | 2 | 2 | 3 | 3 | 4 | 4 | 5 |
| 3 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 
| 4 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

세번째 숫자를 고르는 경우도 마찬가지

|   | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 
|---|---|---|---|---|---|---|---|---|---|---|
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 2 | 0 | 1 | 1 | 2 | 2 | 3 | 3 | 4 | 4 | 5 |
| 3 | 0 | 0 | 0 | 1 | 1 | 2 | 2 | 4 | 4 | 6 | 
| 4 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 2 |

그러면 10까지의 숫자에서 선영이가 4개의 숫자로 로또 숫자 배열을 만들 수 있는 경우의 수는 가장 마지막 줄의 숫자를 모두 더해서 4이다.

그러면 어떤 순서 tn에서 어떤 숫자 tm을 고를 수 있는 경우의 수를 f(tn, tm) 이라고 하면

```
f(1, 1) = 1
:
f(2, 1) = 0
f(2, 2) = f(1, 1)
f(2, 3) = f(1, 1)
f(2, 4) = f(1, 1) + f(1, 2)
f(2, 5) = f(1, 1) + f(1, 2)
f(2, 6) = f(1, 1) + f(1, 2) + f(1, 3)
:
f(3, 1) = 0
f(3, 2) = f(2, 1)
f(3, 3) = f(2, 1)
f(3, 4) = f(2, 1) + f(2, 2)
:
f(tn, tm) = f(tn-1, tm/2) + f(tn-1, tm/2-1) + ... f(tn-1, 1)
```
이렇게 된다.

그런데 이때 f(tn, tm-2)는 다음과 같다.

```
f(tn, tm-2) = f(tn-1, (tm-2)/2) + f(tn-1, (tm-2)/2-1) + ... f(tn-1, 1)
            = f(tn-1, tm/2-1) + f(tn-1, tm/2-2) + ... f(tn-1, 1)
```

따라서

```
f(tn, tm) = f(tn-1, tm/2) + f(tn, tm-2)
```
