# 첫번째 시도 230808
로직을 잘못 생각했다. 앞의 숫자를 선택하고 나서 뒤에 선택가능한 숫자를 고르는 과정은 앞의 과정과 완전히 동일하지 않다.

1을 고르고 두번째 숫자를 골라야 할 때 가능한 숫자는

2, 3, 4, ..

이때 두번째로 2를 고르면 세번째 숫자를 골라야 할 때 가능한 숫자는

4, 5, 6, ..

가장 똑같이 가장 앞에 있는 숫자를 고르더라도 

첫번째 숫자인 1을 골랐을 때는 바로 다음 수부터 고르기 가능하지만,

두번재 숫자인 2를 골랐을 때는 바로 다음 수인 3부터 고를 수 없다. 

그런 이유로 다음과 같은 로직은 성립할 수 없다

```cpp
#include <iostream>

using namespace std;

int t,n,m,ans;
int dp[11][2001];

int choose(int tn, int tm) {
    if(tn > tm) return -1;
	if(dp[tn][tm]!=0) return dp[tn][tm];
	if(tn == 1) dp[tn][tm] = tm;
	else {
	    for(int i=0; 2*i+1 < tm && tn <= tm-2*i; i++) {
	    	dp[tn][tm] += choose(tn-1,tm-2*i-1);
	    }
	}
	return dp[tn][tm];
}

int main() {
	cin >> t;
	while(t--) {
		cin >> n >> m;
		ans = choose(n,m);
        if(ans > 0) cout << ans << '\n';
        else cout << "-1\n";
	}
	return 0;
}
```
